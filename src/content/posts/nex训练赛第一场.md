---
title: nex训练赛第一场
published: 2025-03-26
description: ''
image: ''
tags: [wireshark,RSA,LCG,sagemath,ECC]
category: 'ctf'
draft: false 
lang: ''
---
# nex练习赛第一场

## misc
### 1.破译！
签到题!直接用wireshark看流量日志的icmp信息,发现每一段偷偷发了一个字符,拼起来就是flag


>nex{TSHARK_4nAIYSe_dAtA}

## crypto
### 1.密码神的庇护
简单的RSA,解出p，q即可获取私钥d,从而还原m.

题目中给出p,q的平方和的具体数值

采用two_squares函数分解

```python
hint=113345597990170611084507248218732266936697638310719157069667409300763137634370
print(two_squares(hint))
```

得到p,q的值进而解出r，d以及m

```python
from Crypto.Util.number import *
from gmpy2 import *
n = 13388413226974557581704281854845886646113547870484590783056246042959324289283868380160534582158491845920746847864193
c = 10127254355951585212836546225982609559212143192257147541532354003875637740864769668038875113694873231072365570968808
p = 196011681709922710737506615251644077633
q = 273724347881986124491780459692944906209
e = 65537
r =n//(p*q)
phi = (p-1)*(q-1)*(r-1)
d=invert(e,phi)
m=pow(c,d,n)
print(long_to_bytes(m))
```

最终得到flag


>nex{sagemath_orz_orz}


### 2.Modulus_Wanderer
LCG(<font style="color:rgb(51, 51, 51);">Linear congruential generator</font>)线性同余生成器,是一种古老但有效的随机数生成方法,可以生成一串看似随机的数

以下是生成原理

$ X_{n+1}=(AX_n+B) \bmod p $

可以很明显的看出,只要知道了生成器对应的参数以及其生成的某一个数,那么这个数之前和之后的任何一个数都是可预测的

题中给出的hint1和hint2实际上是给出生成器生成的第一个数和第十一个数对应的数字

也就是说

$$题中A,p是已知的,B是未知的,并且我们知道X_{11}和X_{1},\\要求X_0,也就是种子.我们考虑先求出B,我们有:\\X_2=(AX_1+B)\bmod p\\X_3=(AX2+B) \bmod p\\......\\X_{11}=(AX_{10}+B) \bmod p\\也就是说,这些等量关系都是在特征值为p的有限域上成立的\\将每个X的值用前一个等式代入,我们有\\X_{11}=[A(AX_9+B)+B]\bmod p\\=(A^2X_9+AB+B)\bmod p\\=[A^2(AX_8+B)+AB+B]\bmod p\\=[A^3X_8+B(A^2+A^1+A^0)]\bmod p\\一直这么做下去,得到X_{11}和X_1的关系\\X_{11}=(A^{10}X1+BS)\bmod p\\S=\frac{A^{10}-1}{A-1}\\于是可以解得B\\B=S^{-1}(X_{11}-A^{10}X_1)\bmod p\\其中S^{-1}是S对于模p意义下的乘法逆元\\解得B之后,很容易解得X_0,进而得到flag\\X_1=AX_0+B\\X_0=A^{-1}(X_1-B)\bmod p\\同样的,A^{-1}是A在模p意义下的乘法逆元$$

```python
from gmpy2 import *
from math import *
from Crypto.Util.number import *

X1=22126701685602448167153832064764403297274733309207994531721460922137730181263
X11=5876222187265536012720939816304551139744973373899661196587843114977386227647
A=45050661441957622790575103855445161637213342339326319451297390136793503480151
P=62520448412578189384348150589336657827821981805797503110824753389166180072583
S=A**10//(A-1)
    
S_inv=inverse(S,P)
B=((X11-(A**10)*X1)*S_inv)%P
A_inv=inverse(A,P)
X0=(X1-B)*A_inv%P
print(long_to_bytes(X0))

```

:::tips
nex{4sdJKAndJA5bDhjA5Bhj8wd}

:::

### 3.eccccccc
椭圆曲线上的点运算是一个新的运算系统,有着非常良好的适宜加密的性质,实际上真正的加密过程一般在某个有限域内进行

我们实际上要还原M点(明文)的坐标,题中给了C1,C2(密文),k(私钥),G(基点),p(有限域的特征值),实际上就只是正常的解密也就是:

M=C1-r\*K=C1-r\*k\*G=C1-k\*r\*G=C1-k\*C2

C1,C2,k均已知,我们只是不知道椭圆曲线的参数,接下来我们计算参数a,b.

$ 这一切都在特征值为p的有限域上进行,\\
我们有基点G(x_0,y_0),C_1(x_1,y_1),C_2(x_2,y_2)都在该曲线上,我们任取两点得到等量关系\\
y_0^2\equiv x_0^3+ax_0+b \pmod{p}\\
y_1^2\equiv x_1^3+ax_1+b \pmod{p}\\
消去b,得到\\
a=(x_0-x_1)^{-1}(y_0^2-y_1^2+x_1^3-x_0^3)\bmod p\\
其中(x_0-x_1)^{-1}是x_0-x_1在模p意义下的乘法逆元\\
得到a后回代解得b
 $

```python
from Crypto.Util.number import *
from gmpy2 import *
x0,y0=24371871106124476608129413018007683749593371876591183243338933810740838981348,23015106611547118016099216957370382973295772903171560590540086936632691815266
x1,y1=35029809461713077317422176208199593555808753962227199553663746436989476630549,70284608881898175768330244696144470553229690624724450106387871993242473714149
x2,y2=81210585467356603748617604091672343342945104102392860796895234825664119090771,23227337141205320706787302225769970768948777771811115448021923519236775055822
p=86363197701610111660590410934823244920604361642620632441265552077801287357143
inv=inverse(x0-x1,p)
a=((y0**2-y1**2+x1**3-x0**3)*inv)%p
b=(y1**2-x1**3-x1*a)%p
print(a,b)
```

然后到sagemath中调用sage.all中的椭圆曲线的函数,解得M点坐标

```python
from sage.all import *
x0,y0=24371871106124476608129413018007683749593371876591183243338933810740838981348,23015106611547118016099216957370382973295772903171560590540086936632691815266
x1,y1=35029809461713077317422176208199593555808753962227199553663746436989476630549,70284608881898175768330244696144470553229690624724450106387871993242473714149
x2,y2=81210585467356603748617604091672343342945104102392860796895234825664119090771,23227337141205320706787302225769970768948777771811115448021923519236775055822
p=86363197701610111660590410934823244920604361642620632441265552077801287357143
a,b=10972206021050843715713867075447019754368995699453705061956640642463360719990,43116095427195735418696366620170388327950970049667929605192635291377105319871
k = 49823773177495327395329160854015772265091002280747427978872716912334358314732
F=GF(p)
E=EllipticCurve(F,[a,b])
G=E((x0,y0))
C1=E((x1,y1))
C2=E((x2,y2))
M=C1-k*C2
print(M)
```

输出:(2461921310695640367443779623289073583244145533 : 59777223343166532100548731078080223408775683954385654216372214973477821831543 : 1)

```python
from Crypto.Util.number import *
print(long_to_bytes(2461921310695640367443779623289073583244145533))
```


>nex{sakjdnsadsasss}(后面的flag怎么感觉是脸滚键盘)

