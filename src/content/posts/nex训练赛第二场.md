---
title: nex训练赛第二场
published: 2025-03-27
description: '这周的题目也挺友好的'
image: ''
tags: [RSA,python.random,coopersmith,DH]
category: 'ctf'
draft: false 
lang: ''
---
# nex练习赛第二场

## Crypto
### 1.MCGA
题干代码:

```python
import random
from Crypto.Util.number import *
import os

flag = os.getenv('FLAG')
real = '关于下周就上完所有课了以为可以走了却发现还要多留几周考人文选修这件事'
flag1 = flag[:len(flag)//2]
flag2 = flag[len(flag)//2:]


def get_hex_input(prompt):
    while True:
        user_input = input(prompt)
        try:
            return int(user_input, 16)
        except ValueError:
            print("Invalid input. Please enter a valid hexadecimal number.")


def first_task():
    random.seed(real)
    r = random.getrandbits(128)

    seed = get_hex_input("(TASK1) Give me the seed (hex):")

    if seed == bytes_to_long(real.encode()):
        print("Seed cannot be the same as the 'real' value.")
        exit(1)

    random.seed(seed)
    
    if r != random.getrandbits(128):
        print("Random number mismatch.")
        exit(1)
    
    print(f"flag1 = {flag1}")

def second_task():
    p = getPrime(256)
    print(f"p = {p}")

    m = get_hex_input("(TASK2): Enter your message (hex):")

    if real.encode() not in long_to_bytes(m):
        print("Error: The message does not contain the 'real' value.")
        exit(1)
    
    if pow(2, m, p) != 1:
        print("Error: pow(2, m, p) is not equal to 1.")
        exit(1)

    print(f"flag2 = {flag2}")

def main():
    first_task()
    second_task()

if __name__ == "__main__":
    main()

```

可以看到flag分两段加密

first_task要求一个十六进制值,其中该十六进制值作为种子和real字符串作为种子得到的对应生成的数字应该是一样的,所以我们要知道random库中的该函数到底是怎么接受不同类型的种子的

看看random库源码:

```python
def seed(self, a=None, version=2):
        """Initialize internal state from a seed.

        The only supported seed types are None, int, float,
        str, bytes, and bytearray.

        None or no argument seeds from current time or from an operating
        system specific randomness source if available.

        If *a* is an int, all bits are used.

        For version 2 (the default), all of the bits are used if *a* is a str,
        bytes, or bytearray.  For version 1 (provided for reproducing random
        sequences from older versions of Python), the algorithm for str and
        bytes generates a narrower range of seeds.

        """

        if version == 1 and isinstance(a, (str, bytes)):
            a = a.decode('latin-1') if isinstance(a, bytes) else a
            x = ord(a[0]) << 7 if a else 0
            for c in map(ord, a):
                x = ((1000003 * x) ^ c) & 0xFFFFFFFFFFFFFFFF
            x ^= len(a)
            a = -2 if x == -1 else x

        elif version == 2 and isinstance(a, (str, bytes, bytearray)):
            if isinstance(a, str):
                a = a.encode()
            a = int.from_bytes(a + _sha512(a).digest(), 'big')

        elif not isinstance(a, (type(None), int, float, str, bytes, bytearray)):
            _warn('Seeding based on hashing is deprecated\n'
                  'since Python 3.9 and will be removed in a subsequent '
                  'version. The only \n'
                  'supported seed types are: None, '
                  'int, float, str, bytes, and bytearray.',
                  DeprecationWarning, 2)

        super().seed(a)
        self.gauss_next = None
```

其中seed接收的version参数不用管,现在的环境下基本上version都默认为2.在version==2时,其中如果接收的参数a是数字类型则直接作为作为种子,如果参数a是字符串,就要经过一个变换得到对应的数字

重点代码:

```python
if isinstance(a, str):
                a = a.encode()
            a = int.from_bytes(a + _sha512(a).digest(), 'big')
```

先将该字符串编码为字节,然后sha512生成a的一个摘要,然后转换成一个大整数,我们只需要照着这个一样做,然后把转换得到的大整数以十六进制的方式输出就行了

second_task要求一个十六进制数值m,其中该十六进制数值经过longtobytes转换得到的结果要"包含"real,同时要满足pow(2,m,p)==1,p是一个容器中会给出的512位大整数

我们先求m应该满足的数值上的条件:

$ 由费马小定理,我们有:2^{p-1}=1\bmod p\\
同时题目要满足2^m=1\bmod p
我们有2^{p-1}=kp+1,k是一个整数\\
所以2^{n(p-1)}(其中n是自然数)=(kp+1)^n,根据二项展开只有一项没有因数p\\
所以我们有2^{n(p-1)}=1\bmod p\\
所以我们考虑构造m=0\bmod {p-1}\\
 $

由于题目要求该十六进制数值经过longtobytes转换得到的结果应该包含real,所以我们肯定要看看long和bytes类型是怎么转化的,实际上,从bytes类型转换为long类型是从最低位开始,每一位字节乘上对应位置的乘数加在一起,其中最低位乘数为2^0,每升高一位乘数乘上2\*\*8.

根据这个原理,我们可以得出我们只需要构造一个数k(也就是加在real对应的新的最高位的字节的ascii码值),我们设x=bytes_to_long(real.encode()),m=k\*2\*\*(103\*8)+2\*\*8\*x+0\*2\*\*8(由于x是一个奇数,而其他数都是偶数,我们在最低位加上一个0,同时整体升高一位,便于计算)

此时,设y=2\*\*(103\*8),我们有:

$ m=ky+x\\
ky+x\equiv0 \pmod{p-1}\\
ky\equiv-x \pmod{p-1}\\
由于上面所有数都有公因数2,所以我们都除2\\
k\frac{y}{2}\equiv-\frac{x}{2}\pmod {\frac{p-1}{2}}\\
故k=(-\frac{x}{2})(\frac{y}{2})^{-1}\pmod {\frac{p-1}2}\\ $

但这样求出来的k是一个很大的数,再将k的十六进制表示和x的至六进制表示拼起来就得到m

```python
import random
import hashlib
from Crypto.Util.number import *
real = '关于下周就上完所有课了以为可以走了却发现还要多留几周考人文选修这件事'

a = real.encode()

newsha512 = hashlib.sha512()
newsha512.update(a)
hashvalue = newsha512.hexdigest()

hash_bytes = newsha512.digest()

combined_bytes = a + hash_bytes

a = int.from_bytes(combined_bytes, 'big')
p = 106543106872248388902823970524656574277532840457483530072580713851247630064931



x=2**8*bytes_to_long(real.encode())
y=2**824
inv=inverse(-y//2,(p-1)//2)
k=x//2 * inv
print(hex(k))
print(hex(x))
m=0x27e8d11541deb17976bf37808db23dea52368240b94b6c978ae29fd968715e8432b46388cf226a07e4c6599beaf8873f8e750244db72219ce48c5f6ed23d9e594befd6f0cc1330a7a8e8b33f23cda42a0956c09eb35c3a7aeb1366e0c373d7ab093d223ea2384759545dd94667150c1a2254d0084097c08785304b3e724cd38ad7fde43d112300e585b3e4ba8ee4b88be591a8e5b0b1e4b88ae5ae8ce68980e69c89e8afbee4ba86e4bba5e4b8bae58fafe4bba5e8b5b0e4ba86e58db4e58f91e78eb0e8bf98e8a681e5a49ae79599e587a0e591a8e88083e4babae69687e98089e4bfaee8bf99e4bbb6e4ba8b00



```

> nex{jUsT_s0m3_FuNNy_7hIN9_480Ut_CryP70chzno6ph}

### 2.DH
这题的p应该足够大,这样才不会导致关于m的信息丢失,但是p大了又难以解密,那我们该怎么办呢?肯定要生成一个特定的p,这样的p足够大,又便于攻击

查查资料,发现我们可以构造p-1可以被分成许多个小素数(p-1是光滑数),这样就可以直接用sagemath根据公钥轻松算出私钥

```python
def generate_large_prime():
    
    small_primes = [35993, 49019, 39847, 51581, 35747, 52769, 43541, 37049, 42719, 48481, 35447, 41023, 63667, 61703, 46103, 42323, 47713, 38747, 43943, 63391, 46829, 63907, 38189, 42209, 62791, 36469, 54323, 64237, 44819, 41641]
    
    
    N = 1
    for prime in small_primes:
        N *= prime
    

    k = 1
    while True:
        p = k * N + 1
        if isPrime(p):
            return p
        k += 1

p = generate_large_prime()
print(f"生成的大质数p: {p}")
```

然后从题目中得到公钥A,B

sagemath启动

```python
from sage.all import *
R = GF(10381308740568906320649437199446109294524545328669765569307250513687762683086581524706479394359187430243008400917367003858934120033070691022771)
x = R(1044892704070333383730463528377652153835323442378313262986636244081424596016672877044711180783991307676660672255486814245279689443457594694798).log(2)
print(x)
```

得到私钥a.b,后面求解m就很简单了

```python
from Crypto.Util.number import *
a=1905313283090116270535225909578252528454126401575031758459652180476126038349794919029030868551949867327645543953355056636236202210491572136005
A=8800941065002450624998421490713743513120560088083592740332295340760969458330130753598845914215296263324352176455911853580940468070292721697673
B=1044892704070333383730463528377652153835323442378313262986636244081424596016672877044711180783991307676660672255486814245279689443457594694798
b=199643835786225098626468334685194466673128508335745944435691258262773694993471250976815095437652720460759124745862403089314267078180450214036
C=2918957159231597354577889949476898558021454332225063631241713808285741007070060231351416432146574428036218751101234011497316638122148265797959
key=pow(A,b,p)
m=(C*inverse(key,p))%p
print(m)
```

> nex{lN_50me_CASe_dh_n07_s4le_4jfo5p1l}

### 3.铜匠
不是很懂原理,但是我可以当脚本小子.

根据题干的指引,事实上p泄露了低282位,满足coopersmith攻击的条件,我们直接用sagemath求解每一次加密对应的p

```python
from sage.all import *



def getFullP(low_p, n):
    R.<x> = PolynomialRing(Zmod(n), implementation='NTL')
    p = x*2^282 + low_p
    root = (p-n).monic().small_roots(X = 2^230, beta = 0.4)
    if root:
        return p(root[0])
    return None

c = 10563094101034811553454712900719806255688808214255587200479638798540644846061523163891930248220417607389716920273654765904220108653115748948743637158939621592304633876462240966186359871000407712654040081349014821220117590432208035691480792313127632545480379611791569038395523238403311261823962329584825993
hint1 = [29273299856954369994256087640892258024490764559618652986056435275749516642274619356441039235571506570658990661482301165619265799030532026795226581389279077770038535298596979943503795189290932605639594274220202605500082129277336207983070800192129487486968145013807896570315812760991912922676635133499936687, 20331052157078100785675692773997643269602645338034965925565589874957320445186754202582903860504277783349278546620351745549825171355632775985630926038354599731300018102755268996359923004417111350495336428822837818704160310752133567901708971364693022447802147188397534391889094780114557902850785654484278751, 35979522220631966982525912945997630886322818515462204518619661283985850245661220048564122969837519709631310435306659850280426859969476148032004740421607943735291405361057344803589437911327927958716854951380164541422290140798792796150251680509103892624187235054756965178399564960807295297176044433588330403, 27300290935172109614348002913770852804642910384723302946874875148700718670341527589067804991448719045505032826898398616991003086242495780110353236552010738603459647649803522038709346587480365483441857264369054855840110928199556981878804028610015901125331527811836089812024266713664970824402038873367637541, 23760816424392667354798768262551742014994151574271651618622364608560030015232454992127788005400045881339370196858094093706715064612537388812031853327962100818981804146166924742178350386940676786479669683026165944827957217063457195826957737768148944613385027603445123288081646286872484271417045031438460007, 32500221018379817448895313807264076535052866853401740604084700093981013108210416561822708101063319438841782894087756910036760327015005933628674515582034028835538232351597636807874056845253426688991568545671341230655976415905496212744735919718090465328401533545078180796735521789686507046668517039741315827]
hint2 = [18885335020869539533593170581198006027170508185619099561537838650710745657508031663652600756754947943599876889964606528313061989882844492583669222520856857, 12686370307445303824404868020277764075451699008353766334235401524746460531545441115403263629051847808959282944024684596643953648167683979719483519214092519, 15044418105987274386964561463425599456335835597186871606538685436733749834787227305631265090256002020234604070971660724216505488595447847389873587343981723, 22405784394723616753983345443361910704741234855696855469952122038287244544863931506791745007703095973050129193347242219537788649249253238543577534296336303, 18137240423109140754616885927502956623355102662364449969429955792633668970614172896224882410426560108655839989193306230513129777732570821029053636843499343, 18655999375760410956095270661113865811257923987503812830216891338748356554253194427617647531869863349318207805897667876714828896616719574381120842197209463]

P=[]

for i in range(6):
    P.append(getFullP(hint2[5-i],hint1[5-i]))
print(P)
    
```

得到列表P之后,我们再连续解密得到m

```python
from Crypto.Util.number import *
import random

c = 10563094101034811553454712900719806255688808214255587200479638798540644846061523163891930248220417607389716920273654765904220108653115748948743637158939621592304633876462240966186359871000407712654040081349014821220117590432208035691480792313127632545480379611791569038395523238403311261823962329584825993
hint1 = [29273299856954369994256087640892258024490764559618652986056435275749516642274619356441039235571506570658990661482301165619265799030532026795226581389279077770038535298596979943503795189290932605639594274220202605500082129277336207983070800192129487486968145013807896570315812760991912922676635133499936687, 20331052157078100785675692773997643269602645338034965925565589874957320445186754202582903860504277783349278546620351745549825171355632775985630926038354599731300018102755268996359923004417111350495336428822837818704160310752133567901708971364693022447802147188397534391889094780114557902850785654484278751, 35979522220631966982525912945997630886322818515462204518619661283985850245661220048564122969837519709631310435306659850280426859969476148032004740421607943735291405361057344803589437911327927958716854951380164541422290140798792796150251680509103892624187235054756965178399564960807295297176044433588330403, 27300290935172109614348002913770852804642910384723302946874875148700718670341527589067804991448719045505032826898398616991003086242495780110353236552010738603459647649803522038709346587480365483441857264369054855840110928199556981878804028610015901125331527811836089812024266713664970824402038873367637541, 23760816424392667354798768262551742014994151574271651618622364608560030015232454992127788005400045881339370196858094093706715064612537388812031853327962100818981804146166924742178350386940676786479669683026165944827957217063457195826957737768148944613385027603445123288081646286872484271417045031438460007, 32500221018379817448895313807264076535052866853401740604084700093981013108210416561822708101063319438841782894087756910036760327015005933628674515582034028835538232351597636807874056845253426688991568545671341230655976415905496212744735919718090465328401533545078180796735521789686507046668517039741315827]
hint2 = [18885335020869539533593170581198006027170508185619099561537838650710745657508031663652600756754947943599876889964606528313061989882844492583669222520856857, 12686370307445303824404868020277764075451699008353766334235401524746460531545441115403263629051847808959282944024684596643953648167683979719483519214092519, 15044418105987274386964561463425599456335835597186871606538685436733749834787227305631265090256002020234604070971660724216505488595447847389873587343981723, 22405784394723616753983345443361910704741234855696855469952122038287244544863931506791745007703095973050129193347242219537788649249253238543577534296336303, 18137240423109140754616885927502956623355102662364449969429955792633668970614172896224882410426560108655839989193306230513129777732570821029053636843499343, 18655999375760410956095270661113865811257923987503812830216891338748356554253194427617647531869863349318207805897667876714828896616719574381120842197209463]
e=65537
C=[c]
P=[10704663047576178111865544452387208496669016973379556707641785082551872511238440588081176727473399999215340011324010776462414120936788009404209679850115447, 7458970535649456031167788053076787626361760558055793791861074274551053918098760976829017695716869159926910176457802855164599769056723277996740857935523663, 12949359978306860961128175542811111199038485148565603499032714948368953403909134856151768999676126925937623105571156627855727638381826697196510073792604079, 11798773715187510930390552639475554896591166545914518720741662843505861023679226910336541844326482659419568423409181016655404670058581213256911334369262747, 7796901165649048682216476206614097190010141865384402643092550356540882760484485098622828029935116598400913396213193955821306755392874755343013373448880359, 13245106872383967033899048362475738592958977168667496529973584755509820266794798167922593895635052572860983290028336679195241683759444457896763045829353753]



def rsaDecrypt(n,p,c):
    q=n//p
    phi=(p-1)*(q-1)
    d=inverse(e,phi)
    m=pow(c,d,n)
    return m

for i in range(6):
    m=rsaDecrypt(hint1[5-i],P[i],C[i])
    C.append(m)


print(long_to_bytes(m))


```

> nex{yOu_NeV3r_ForbeT_c0pPERsmITH}

